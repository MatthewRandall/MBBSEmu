using Iced.Intel;
using MBBSEmu.Disassembler.Artifacts;
using MBBSEmu.Logging;
using NLog;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MBBSEmu.CPU
{
    /// <summary>
    ///     Handles Memory Operations for the CPU Emulator
    ///
    ///     Memory is split into two regions:
    ///     1. Module Memory Space, which is used to host the module code/data segments
    ///     2. Host Memory Space, which is used to host memory/pointers generated by the MajorBBS/WG host software.
    ///
    ///     Functions within MajorBBS such as alczer(), alcblok(), etc. live within the host process memory regions and are accessed
    ///     by the imported functions. Pointers to these regions are passed back the module and saved in the module data segments.
    ///
    ///     Information of x86 Memory Segmentation: https://en.wikipedia.org/wiki/X86_memory_segmentation
    /// </summary>
    public class CpuMemory
    {
        protected static readonly Logger _logger = LogManager.GetCurrentClassLogger(typeof(CustomLogger));

        /// <summary>
        ///     8MB Module Memory Space
        /// </summary>
        public byte[] _moduleMemorySpace;


        public Dictionary<int, int> _segmentAddressTable;
        public Dictionary<int, InstructionList> _decodedSegments;
        public Dictionary<int, Segment> _segments;
        public const int SEGMENT_BASE = 0x010000;
        public const int STACK_BASE = 0x8000;

        public CpuMemory()
        {
            _moduleMemorySpace = new byte[0x800000];
            _segmentAddressTable = new Dictionary<int, int>();
            _decodedSegments = new Dictionary<int, InstructionList>();
            _segments = new Dictionary<int, Segment>();

            _logger.Info("CPU Memory Space Initialized");
        }

        public int AddSegment(Segment segment)
        {
            //Get Address for this Segment
            var segmentOffset = SEGMENT_BASE + (SEGMENT_BASE * _segmentAddressTable.Count);
            
            //Add the data to memory and record the segment offset in memory
            Array.Copy(segment.Data, 0, _moduleMemorySpace, segmentOffset, segment.Data.Length);
            _segmentAddressTable.Add(segment.Ordinal, segmentOffset);

            if (segment.Flags.Contains(EnumSegmentFlags.Code))
            {
                //Decode the Segment
                var instructionList = new InstructionList();
                var codeReader = new ByteArrayCodeReader(segment.Data);
                var decoder = Decoder.Create(16, codeReader);
                decoder.IP = 0x0;

                while (decoder.IP < (ulong)segment.Data.Length)
                {
                    decoder.Decode(out instructionList.AllocUninitializedElement());
                }

                _decodedSegments[segment.Ordinal] = instructionList;
            }

            _segments[segment.Ordinal] = segment;
            return segmentOffset;
        }

        public Instruction GetInstruction(int segment, int instructionPointer)
        {
            return _decodedSegments[segment].First(x => x.IP16 == instructionPointer);
        }

        public int GetByte(int segment, int offset)
        {
            var segmentOffset = _segmentAddressTable[segment];
            return _moduleMemorySpace[segmentOffset + offset];
        }

        public int GetWord(int segment, int offset)
        {
            var segmentOffset = _segmentAddressTable[segment];
            return BitConverter.ToUInt16(_moduleMemorySpace, segmentOffset + offset);
        }

        public byte[] GetArray(int segment, int offset, int count)
        {
            var output = new byte[count];
            var segmentOffset = _segmentAddressTable[segment];
            Array.Copy(_moduleMemorySpace, segmentOffset + offset, output, 0, count);
            return output;
        }


        /// <summary>
        ///     Reads an array of bytes from the specified segment:offset, stopping
        ///     at the first null character denoting the end of the string.
        /// </summary>
        /// <param name="segment"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public byte[] GetString(int segment, int offset)
        {
            var output = new List<byte>();
            var segmentOffset = _segmentAddressTable[segment];
            for (var i = 0; i < ushort.MaxValue; i++)
            {
                var inputByte = _moduleMemorySpace[segmentOffset + offset + i];
                output.Add(inputByte);
                if (inputByte == 0)
                    break;
            }

            return output.ToArray();
        }

        public void SetByte(int segment, int offset, byte value)
        {
            var segmentOffset = _segmentAddressTable[segment];
            _moduleMemorySpace[segmentOffset + offset] = value;
        }

        

        public void SetWord(int segment, int offset, ushort value)
        {
            var segmentOffset = _segmentAddressTable[segment];
            Array.Copy(BitConverter.GetBytes(value), 0, _moduleMemorySpace, segmentOffset + offset, 2);
        }

        public void SetArray(int segment, int offset, byte[] array)
        {
            var segmentOffset = _segmentAddressTable[segment];
            Array.Copy(array, 0, _moduleMemorySpace, segmentOffset + offset, array.Length);
        }

        

        public ushort Pop(int stackPointer)
        {
            return BitConverter.ToUInt16(_moduleMemorySpace, stackPointer);
        }

        public void Push(int stackPointer, byte[] value)
        {
            if (value.Length > 2)
            {
#if DEBUG
                _logger.Warn($"{value.Length} bytes passed in, truncating to 16-bit. New value {BitConverter.ToUInt16(value)}");
#endif
                Array.Copy(value, 0, _moduleMemorySpace,  stackPointer, 2);
                return;
            }

            if (value.Length == 0)
                return;

            Array.Copy(value, 0, _moduleMemorySpace,  stackPointer, 2);
        }
    }
}
