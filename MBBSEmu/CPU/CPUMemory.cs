using MBBSEmu.CPU.Memory;
using System;
using System.Collections.Generic;
using System.Linq;
using Iced.Intel;
using MBBSEmu.Disassembler.Artifacts;

namespace MBBSEmu.CPU
{
    /// <summary>
    ///     Handles Memory Operations for the CPU Emulator
    ///
    ///     Memory is split into two regions:
    ///     1. Module Memory Space, which is used to host the module code/data segments
    ///     2. Host Memory Space, which is used to host memory/pointers generated by the MajorBBS/WG host software.
    ///
    ///     Functions within MajorBBS such as alczer(), alcblok(), etc. live within the host process memory regions and are accessed
    ///     by the imported functions. Pointers to these regions are passed back the module and saved in the module data segments.
    ///
    ///     Information of x86 Memory Segmentation: https://en.wikipedia.org/wiki/X86_memory_segmentation
    /// </summary>
    public class CpuMemory
    {
        /// <summary>
        ///     8MB Module Memory Space
        /// </summary>
        public byte[] _moduleMemorySpace;

        /// <summary>
        ///     Host Process Memory Space
        /// </summary>
        public byte[] _hostMemorySpace;


        public Dictionary<int, RelocatedMemoryObject> _memoryRelocation;
        public Dictionary<int, int> _segmentAddressTable;
        public Dictionary<int, InstructionList> _decodedSegments;
        public Dictionary<int, Segment> _segments;
        public const int SEGMENT_BASE = 0x010000;
        public const int STACK_BASE = 0x8000;

        /// <summary>
        ///     As memory is allocated, this will be incremented
        /// </summary>
        private int _hostMemoryPointer = 0x0;

        public CpuMemory()
        {
            _moduleMemorySpace = new byte[0x800000];
            _hostMemorySpace = new byte[0x800000];
            _memoryRelocation = new Dictionary<int, RelocatedMemoryObject>();
            _segmentAddressTable = new Dictionary<int, int>();
            _decodedSegments = new Dictionary<int, InstructionList>();
            _segments = new Dictionary<int, Segment>();
            Console.WriteLine("X86_16 Memory Space Initialized!");
        }

        public int AddSegment(Segment segment)
        {
            //Get Address for this Segment
            var segmentOffset = SEGMENT_BASE + (SEGMENT_BASE * _segmentAddressTable.Count);
            
            //Add the data to memory and record the segment offset in memory
            Array.Copy(segment.Data, 0, _moduleMemorySpace, segmentOffset, segment.Data.Length);
            _segmentAddressTable.Add(segment.Ordinal, segmentOffset);

            if (segment.Flags.Contains(EnumSegmentFlags.Code))
            {
                //Decode the Segment
                var instructionList = new InstructionList();
                var codeReader = new ByteArrayCodeReader(segment.Data);
                var decoder = Decoder.Create(16, codeReader);
                decoder.IP = 0x0;

                while (decoder.IP < (ulong)segment.Data.Length)
                {
                    decoder.Decode(out instructionList.AllocUninitializedElement());
                }

                _decodedSegments[segment.Ordinal] = instructionList;
            }

            _segments[segment.Ordinal] = segment;
            return segmentOffset;
        }

        public Instruction GetInstruction(int segment, int instructionPointer)
        {
            return _decodedSegments[segment].First(x => x.IP16 == instructionPointer);
        }

        public int GetByte(int segment, int offset)
        {
            var segmentOffset = _segmentAddressTable[segment];
            return _moduleMemorySpace[segmentOffset + offset];
        }

        public int GetWord(int segment, int offset)
        {
            var segmentOffset = _segmentAddressTable[segment];
            return BitConverter.ToUInt16(_moduleMemorySpace, segmentOffset + offset);
        }

        public void SetByte(int segment, int offset, byte value)
        {
            var segmentOffset = _segmentAddressTable[segment];
            _moduleMemorySpace[segmentOffset + offset] = value;
        }

        public void SetWord(int segment, int offset, ushort value)
        {
            var segmentOffset = _segmentAddressTable[segment];
            Array.Copy(BitConverter.GetBytes(value), 0, _moduleMemorySpace, segmentOffset + offset, 2);
        }

        public void PushByte(int stackPointer, byte value) => _moduleMemorySpace[STACK_BASE + stackPointer] = value;

        public void PushWord(int stackPointer, ushort value)
        {
            Array.Copy(BitConverter.GetBytes(value), 0, _moduleMemorySpace, STACK_BASE + stackPointer, 2);
        }

        public byte PopByte(int stackPointer) => _moduleMemorySpace[STACK_BASE + stackPointer];
        public ushort PopWord(int stackPointer) => BitConverter.ToUInt16(_moduleMemorySpace, STACK_BASE + stackPointer);


        public int GetHostByte(int offset) => _hostMemorySpace[offset];
        public int GetHostWord(int offset) => BitConverter.ToUInt16(_hostMemorySpace, offset);
        public void IncrementHostPointer(int offset = 1) => _hostMemoryPointer += offset;
        public int GetHostPointer() => _hostMemoryPointer;
        public void SetHostByte(int offset, byte value) => _hostMemorySpace[offset] = value;
        public void SetHostWord(int offset, ushort value) => Array.Copy(BitConverter.GetBytes(value), 0, _hostMemorySpace, offset, 2);

        public int AllocateHostMemory(int size)
        {
            var currentPointer = _hostMemoryPointer;
            _hostMemoryPointer += size;
            return currentPointer;
        }
    }
}
